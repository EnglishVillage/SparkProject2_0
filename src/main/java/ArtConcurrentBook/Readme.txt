volatile:轻量级的synchronized,在多处理器开发中保证了共享变量的"可见性"

synchronized:Java中的每一个对象(非null对象)都可以作为锁,synchronized给出的答案是在软件层面依赖JVM.
(参考:http://blog.csdn.net/chen77716/article/details/6618779)
	1.对于普通同步方法，锁是当前实例对象(this)
	2.对于静态同步方法，锁是当前类的Class对象(XX.class)
	3.对于同步方法块，锁是Synchonized括号里配置的对象
Lock:Lock给出的方案是在硬件层面依赖特殊的CPU指令


锁的优缺点的对比:
锁					优点								缺点						适用场景
偏向锁(非循环CAS)		加锁和解锁不需要额外的消耗,和执行	如果线程间存在锁竞争,会		适用于只有一个线程访问同步块场景
					非同步方法相比仅存在纳秒级的差距	带来额外的锁撤销的消耗
轻量级锁(循环CAS)		竞争的线程不会阻塞,提高了程序的响	如果始终得不到锁竞争的		追求响应时间,同步块执行速度非常快
					应速度						线程,使用自旋会消耗CPU
重量级锁(循环CAS)		线程竞争不使用自旋,不会消耗CPU	线程阻塞,响应时间缓慢		追求吞吐量,同步块执行速度较长
自旋锁
互斥锁(循环CAS)

如何减少上下文切换:
	无锁并发编程:多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
	CAS算法:Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
	使用最少线程:避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
	使用协程:在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

避免死锁方法:
	避免一个线程同时获取多个锁。
	避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
	尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
	对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

资源限制:
	硬件资源限制:有带宽的上传/下载速度,硬盘读写速度,CPU的处理速度
		解决方案:使用集群并行执行程序(使用ODPS,Hadoop,或者自己搭建服务器集群)
	软件资源限制:有数据库的连接数,socket连接数等
		解决方案:使用资源池将资源复用(使用连接池将数据库和Socket连接复用,或者调用对方webservice接口获取数据时只建立一个连接)
	如何并发编程:根据不同的资源限制调整程序的并发度(个人理解:因为硬件或者软件资源限制,所以线程数太多会造成阻塞,反而更慢)

Java实现原子操作
	1.使用循环CAS实现原子操作(java.util.concurrent.atomic)
	2.使用锁机制实现原子操作

CAS实现原子操作的三大问题:
	1.ABA问题:
		问题:CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。
		解决:使用版本号,AtomicStampedReference.compareAndSet
	2.循环时间长开销大:
		问题:自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
		解决:如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。
	3.只能保证一个共享变量的原子操作:
		问题:当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。
		解决:1.可以用锁
			2.把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。使用AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

线程之间的通信机制:
	1.共享内存:线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。
	2.消息传递:线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。

线程之间如何同步（这里的线程是指并发执行的活动实体）:
	1.共享内存:显式进行的,程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
	2.消息传递:由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。